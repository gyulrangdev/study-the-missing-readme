# 운영 환경을 고려한 코드 작성 (개발 환경과 프로덕션 환경은 엄연히 다르다)

## 개발 환경과 프로덕션 환경은 엄연히 다르다

- 개발 환경은 개발자가 코드를 작성하고 테스트하는 환경이다
- 프로덕션 환경은 코드가 실제로 사용자에게 전달되는 환경이다

운영 가능한 코드란 보호장치, 분석장치, 제어 장치가 내장된 코드. 안저낳고 회복적 있는 코딩 기법을 이용해 방어적으로 프로그래밍해서 시스템을 보호한다.

안전한 코드는 다양한 장애를 극복하며, 회복성을 갖춘 코드는 장애가 발생해도 복구가 가능하다.

용이한 분석으로 위해 로그, 지표, 호출 추적 정보 등을 수집한다.

1. 방어적 프로그래밍을 하자
2. 로깅을 하자
3. 지표를 수집하자
4. 호출 추적 정보를 수집하자

## 방어적 프로그래밍

### null 값 사용은 피하자

null pointer exception을 방지하기 위해 널값을 않는지 검사
메소드 시작 지점에서 해야한다
널 객체 패턴 : 원하는 객체를 찾지 못했을 때 null이 아니라 대체 객체를 반환하는 패턴

### 불변 변수를 사용하자

불변 변수 : 한 번 값이 할당되면 변경할 수 없는 변수
의도치 않게 변경되는 것을 방지하기 위해 사용

### 타입 힌트와 정적 타입 검사를 사용하자

String 타입 보다 Enum 타입을 선언할 수 있다.
변수를 제한하면 예상치 못한 값을 대입해도 버그를 유발하지 않고 그 즉시 실패하게 된다.

- **타입 힌트 예시** Python - 타입을 표시하지만 런타임에는 검사 안 함

```python
  def get_user_role(user_id: int) -> str:
    if user_id == 1:
      return "admin"
    elif user_id == 2:
      return "user"
    else:
      return "guest"
```

- **정적 타입 검사기 예시** TypeScript - 컴파일 시 타입을 실제로 검사

```ts
function getUserRole(userId: number): string {
  if (userId === 1) {
    return "admin";
  } else if (userId === 2) {
    return "user";
  } else {
    return "guest";
  }
}
```

### 입력값을 검사하자

코드로 전달되는 입력값은 절대로 신뢰하지말고 검사해야한다.
사전 조건, 체크섬, 데이터 유효성 검사, 보안 관련 권장 기법, 에러 찾아주는 도구 등 활용

- SQL injection : 입력값을 쿼리에 그대로 사용하는 것
- XSS : 입력값을 HTML에 그대로 사용하는 것
- CSRF : 입력값을 쿼리에 그대로 사용하는 것

어떤 문제가 생길 수 있나요?

- 해커가 입력값을 조작해 공격할 수 있다

공개 우베 애플리케이션 보안 프로젝트 (OWASP) https://owasp.org/www-project-top-ten/ 에서 취약점을 확인할 수 있다.

### 예외를 활용하자

- 특정한 리턴값으로 에러를 표현하지 말자. (ex: 0, -1, null, false)
- Error 클래스를 상속받아 예외를 정의하자.

**예시**

```ts
class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

function parseUserAge(age: unknown): number {
  if (typeof age !== "number" || age < 0) {
    throw new ValidationError("나이는 0 이상의 숫자여야 합니다.");
  }
  return age;
}
```

### 예외는 구체적으로 사용하자

- 가능하면 언어에 내장된 예외를 사용하고, 포관적인 의미를 담는 예외는 만들지 않는다.
- FileNotFoundException, IOException, SQLException 등 언어에 내장된 예외를 사용하자.

- 예외를 애플리케이션 로직에 사용하지 말자

**예시**

```ts
// 잘못된 예시: 예외 처리를 이용해서 애플리케이션 로직을 작성한 경우

function findUser(users: string[], target: string): number {
  try {
    for (let i = 0; i < users.length; i++) {
      if (users[i] === target) {
        return i;
      }
    }
    throw new Error("UserNotFound");
  } catch (e) {
    // 예외를 이용해 없는 사용자를 찾는 로직
    return -1;
  }
}

// 위 예시는 target 사용자가 존재하지 않으면 예외를 발생시키고,
// 예외에서 -1을 반환하여 로직을 흐르게 한다.
// 이런 방식은 예외를 애플리케이션의 일반적인 흐름 제어에 사용하는 잘못된 예다.
```

### 예외는 일찍 던지고 최대한 나중에 처리하자

- "일찍 던진다" : 에러가 발생한 지점으로부터 최대한 가까운 지점에서 예외를 던진다.
- "나중에 처리한다" : 예외를 처리할 적절한 위치에 도착할 때까지 호출 스택을 통해 전파시킨다.

**예시**

```ts
// "예외는 일찍 던지고, 최대한 나중에 처리한다"는 아래와 같이 구현할 수 있다.

// 에러가 발생하면, 바로 예외를 던지고,
// 예외는 호출한 곳에서 적절한 위치(예: 최상위 컨트롤러 등)에서 받아 처리한다.

function riskyOperation(value: number) {
  if (value < 0) {
    throw new Error("value는 0 이상이어야 합니다.");
  }
  // ... 나머지 로직
  return value * 2;
}

function process() {
  // 여기서는 예외를 처리하지 않고, 호출자에게 예외를 전파한다.
  return riskyOperation(-1); // 예외 발생
}

function main() {
  try {
    const result = process(); // 예외가 이곳까지 전파된다.
    console.log("결과:", result);
  } catch (e) {
    // 예외를 여기서 처리한다 (최대한 나중에)
    console.error("오류 발생:", (e as Error).message);
  }
}

main();
```

위 예시에서 `riskyOperation`에서 예외가 발생하면, 바로 처리하지 않고 예외를 던진다.  
중간 함수인 `process`도 예외를 잡지 않고, 최상위 함수인 `main`에서 예외를 받아 적절히 처리한다.

### 재시도는 현명하게

재시도의 시기와 빈도를 판단하기 위해서는 약간의 노하우가 필요하다

가장 손쉬운 방식 : 예외를 잡아서 그 즉시 작업을 다시 시도

-> 재시도한 작업이 실패하면 어떻게 해야할까?

-> 예를들어 디스크에 남는 공간에 없다면 10ms 후에 다시 시도해도 여전히 실패할 것이다.

-> 따라서 BackOff 전략을 사용하는 것이 좋다.

- 백오프 전략: 비선형적으로 대기 시간을 늘리는 방법, 예를들어 10ms, 100ms, 1s, 10s, 100s 등으로 대기 시간을 늘리는 방법을 말한다.

하지만 네트워크 서버에 일시적 문제가 생겨 모든 클라이언트가 동시적으로 장애를 겪는 상황에서 모든 클라이언트가 재시도하면 더 심각한 장애를 유발할 수 있다. (천둥떼 현상 : thundering herd problem)

-> 이러한 상황에서 jitter를 추가하는 것이 좋다. (jitter : 랜덤한 시간을 추가하는 것) jitter를 추가하면 클라이언트가 재시도하는 시간을 랜덤하게 늘리게 되어 요청이 한순간에 몰리는 현상을 방지할 수 있다.

즉, 실패한 요청을 무턱대고 재시도하지는 말자.

### 시스템에 멱등성을 부여하자

멱등성 : 동일한 작업을 여러 번 수행해도 동일한 결과가 나오는 성질

멱등성을 부여하면 재시도해도 문제가 없다.

멱등성을 부여하는 방법 : 요청을 처리하기 전에 요청이 이미 처리되었는지 확인하는 방법

**예시**

원격 API에 클라이언트가 각 요청마다 유일한 ID를 지정하게 하면 멱등성을 구현할 수 있다. 클라이언트가 재시도할 때 실패했던 것과 동일한 요청 ID를 전달하면 된다. 그러면 서버는 이미 해당 요청이 처리된 경우에는 해당 작업을 실행하지 않는다.

```ts
// 서버에서 멱등성을 처리하는 간단한 예시입니다.

type Request = {
  id: string; // 요청마다 고유 ID를 부여
  payload: any;
};

// 서버는 처리된 요청의 ID를 저장해두고 재시도 요청을 구분합니다.
const processedRequests = new Set<string>();

function handleRequest(request: Request) {
  if (processedRequests.has(request.id)) {
    // 이미 처리된 요청이므로 작업을 중복 실행하지 않음
    return { status: "duplicate", message: "이미 처리된 요청입니다." };
  }

  // 실제 작업 처리
  // ...
  processedRequests.add(request.id);

  return { status: "success", message: "요청이 성공적으로 처리되었습니다." };
}

// 클라이언트가 같은 요청을 여러 번 보내도, 서버는 한 번만 처리하고 나머지는 무시합니다.
const req: Request = { id: "unique-req-123", payload: { data: "something" } };

console.log(handleRequest(req)); // { status: "success", ... }
console.log(handleRequest(req)); // { status: "duplicate", ... }
```

### 리소스를 해제하자

장애가 발생하면 모든 리소스를 해제해야한다.
더 이상 필요하지 않은 메모리, 데이터 구조, 네트워크 소켓, 파일 핸들 등을 모두 해제하자.

왜 해야할까?

- 메모리 누수를 방지하기 위해서
- 네트워크 소켓을 해제하지 않으면 불필요한 연결이 남아있어 연결 풀이 가득차게 된다.
- 파일 핸들을 해제하지 않으면 파일 핸들이 고갈될 수 있다.

## 정적 분석 툴

ESLint / TypeScript ESLint: JS·TS에서 타입 불일치, 사용되지 않는 변수, undefined 접근 등을 경고.
방어적 조건 처리나 Null Check 패턴을 규칙으로 추가할 수 있다.

[ESLint 규칙](https://eslint.org/docs/latest/rules)
[타입스크립트의 eslint 규칙](https://typescript-eslint.io/rules/)
[React의 eslint 규칙](https://github.com/jsx-eslint/eslint-plugin-react)

SonarQube: 복잡도, 보안 취약점, 예외 처리 누락, null pointer 가능성 등 방어 코딩 위반을 시각적으로 리포트한다.

## 테스트 및 검증 툴 (Dynamic Analysis)

Jest / Vitest / Playwright test: 단위 테스트와 시나리오 테스트로 방어적 로직의 유효성을 반복 검증.

## 보안 및 런타임 보호 툴

OWASP Dependency-Check, Bandit: 라이브러리 의존관계나 코드 구조에서 방어적 패턴 부재, 취약 의존성을 경고.

Jenkins등 CI/CD 툴과 연동하여 코드 품질을 높인다.

## AI 기반 코드 리뷰 도구

GitHub Copilot / Cody / Taskmaster AI (Anthropic 기반): 코드 중 입력값 검증 누락, try/catch 미처리, Null 안전성 문제를 코드 리뷰 중 자동 제안. AI가 코드의 무결성·예외 처리·입력 검증 여부를 능동적으로 검사하며 PRD와 비교하는
“AI 기반 코드 검증 루프”를 수행.

요즘에는 “정적 분석 + 테스트 자동화 + AI 기반 리뷰" 조합으로 코드 품질을 높이는 것이 일반적이다.
