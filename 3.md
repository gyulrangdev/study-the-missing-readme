# 코드와 함께 춤을 (레거시 코드에 임하는 우리의 자세)

이미 만들어진 기존 코드를 활용해 작업하는 방법, 코드를 엉망으로 만드는 소프트웨어 엔트로피와 기술 부채 등의 개념을 다룬다.

## 소프트웨어 엔트로피는 늘어나게 마련이다

여기저기 코드를 바꾸다 보면 지저분해지는 것은 자연스러운 일이다. 코드가 지저분해지는 것을 **소프트웨어 엔트로피(software entropy)**라고 부른다.

**왜 생길까?**

- 개발자가 다른 사람이 쓴 코드를 이해하지 못하거나, 서로 코딩 스타일이 달라서 발생
- 기술 스택과 제품 요구사항을 개선하다 보면 혼란이 가중

**어떻게 해야 할까?**

- 소프트웨어 엔트로피는 관리가 가능하다
- 코딩 스타일과 버그 탐지 도구는 코드를 깔끔하게 유지하는 데 도움을 준다
- 코드 리뷰 역시 지식을 전파하고 코드의 일관성이 떨어지는 것을 방지하는 데 도움이 된다
- 지속적인 리팩터링을 한다

## 결코 피할 수 없는 기술 부채

**기술 부채(technical debt)**는 기존 코드의 단점을 수정하면서 나중으로 미뤄둔 작업이다. 본질적인 단점을 수정하지 않고 코드를 개선할 때 발생하는 비용을 말한다.

부채는 두려운 것이지만 그렇다고 모든 부채가 나쁜 것만은 아니다.

**신중히 고민하고 의도적으로 만들어진 부채**는 보편적으로 발생하는 기술 부채 유형이다.

- 코드의 단점과 출시 속도 사이에서 고민하다 결정한 실용적인 트레이드오프인 것이다
- 나중에라도 팀이 해결 가능하도록 훈련된 부채라면 이는 좋은 부채라 할 수 있다

**신중했지만 의도치 않게 발생되는 부채**는 성장 과정에서 자연스럽게 나타나는 결과다.

- 건전한 팀은 프로젝트 회고(retrospective) 같은 절차를 활용해 의도치 않았던 부채를 찾아내고 부채의 해결 여부와 적절한 해결 시점을 논의한다

## 기술 부채를 상환하는 방법

문제를 해결할 수 있도록 한 달 동안 온 세상이 멈춰주지는 않는다. 그러니 업무를 진행하면서 필요한 부분은 정리하고 조금씩 리팩터링을 하자. 변경 사항은 작고 독립적인 커밋과 PR(풀 리퀘스트)로 만들자.

**기술 부채를 논의하는 좋은 방법**

1. 상황을 사실 그대로 설명한다
2. 부채의 위험과 비용을 기술한다
3. 해결책을 제안한다
4. (부채를 그대로 두는 방법을 비롯해) 대안에 대해 논의한다
5. 트레이드오프를 따져본다

## 코드 변경으로 인한 고통을 조금이라도 줄이려면

새로운 리포지토리에 코드를 작성하는 것과는 다른 차원의 문제다. 기존의 동작을 유지하면서 변경해야 하기 때문이다. 이미 존재하는 대규모 코드베이스를 변경하는 작업은 사람들이 수년, 혹은 심지어 수십 년에 걸쳐 단련해온 스킬이다. 이 스킬을 익히려면 지금부터 설명하는 몇 가지 팁을 활용해보기 바란다.

### 레거시 코드 변경 알고리즘을 활용하자

1. **변경 지점을 확인한다**

2. **테스트할 지점을 확인한다**

   - 테스트 코드를 결합해서 원하는 입력값을 대입할 수 있도록 코드를 수정해야 한다. 이 변경으로 인해 코드의 동작이 바뀌어서는 안 된다

3. **의존성을 나눈다** (가장 위험한 과정)

   - 조금씩 작업을 진행하되 이 과정에서 새로운 기능을 추가해서는 안 된다
   - 테스트는 자주 실행할 수 있도록 빨리 동작하게 만들자
   - 크고 복잡한 메소드는 더 작은 크기의 메소드로 나눠서 각기 분리된 기능이 독립적으로 테스트될 수 있게 한다
   - 인터페이스(interface) 또는 그 밖의 간접성을 이용해서, 복잡한 객체를 완전하지는 않아도 테스트하기에는 충분한 단순 구현체로 대체할 수 있는 방법을 마련한다
   - 시간의 흐름같이 제어하기 어려운 실행 환경을 시뮬레이션할 수 있는 명시적 제어 지점을 주입한다

4. **테스트를 작성한다**

5. **변경을 적용하고 리팩터링한다**

### 코드는 처음보다 더 깔끔하게 유지하자

- "캠핑장을 떠날 때는 도착했을 때보다 깨끗하게 정리하라"라는 보이스카우트 원칙이 인용된다
- 코드를 정리하는 커밋은 동작을 변경하는 커밋과 구분하자. 커밋을 구분해두면 코드를 정리하는 커밋을 유지하면서도 변경된 코드를 되돌릴 수 있다. 커밋의 크기가 작을수록 변경사항을 리뷰하기도 편하다
- **코드 악취(code smell)**란 버그는 아니지만 문제를 유발할 수 있는 패턴이다. 이름이 너무 긴 메소드나 클래스, 중복 코드, 너무 많은 분기나 루프, 너무 많은 매개변수 같은 문제를 말한다
- 린터(linter)나 코드 품질 도구를 통해 안티 패턴을 확인하고 수정한다

### 점진적으로 변경하자

다음과 같은 것들을 피해야 한다:

- 수십 개의 파일을 한 번에 수정하는 '모조리 바꿔' 식의 변경
- 리팩터링과 새로운 기능이 뒤섞인 PR
  - 커밋을 뒤섞으면 리팩터링한 부분을 유지하면서 기능 변경을 롤백하기가 어려워진다. 따라서 리팩터링 커밋은 작게 유지해야 한다

### 리팩터링은 실용적으로 진행하자

리팩터링이 항상 현명한 결정은 아니다. 마감일도 생각해야 하고 우선순위도 고려해야 한다. 리팩터링을 할 때는 실용성에 무게를 두고 고려하자.

### IDE를 활용하자

IDE는 리팩터링을 할 때 특히 도움이 된다. 이름을 변경하거나 코드의 위치를 바꾸는 기능, 메소드와 필드를 추출하는 기능, 메소드 시그너처(signature)의 수정을 비롯한 다양한 보편적인 작업을 도와주는 여러 기능을 내장하고 있기 때문이다.

IDE가 변경한 코드를 그냥 지나쳐서는 안 된다. IDE를 이용하면 리팩터링이 너무 쉬워서 간단한 수정만으로 엄청난 양의 코드를 변경할 수 있다. 그렇기에 IDE가 자동으로 변경한 내용은 반드시 사람이 리뷰해야 한다.

### 버전 제어 시스템의 권장 기법을 활용하자

변경한 코드는 깃(Git) 같은 버전 제어 시스템(version control system)에 커밋해야 한다.

코드를 개발하는 동안 변경사항은 일찍 그리고 자주 커밋해야 한다. 커밋을 자주 하면 시간의 흐름에 따라 코드가 어떻게 변화해가는지 볼 수 있고, 변경을 되돌릴 수도 있으며, 원격 백업으로서 활용도 가능하다.

리뷰를 요청하기 전에는 브랜치를 리베이스(rebase)하거나 커밋을 스쿼시(squash)해서 커밋 메시지를 명료하게 정리하자.

**커밋 메시지 작성법**

커밋을 스쿼시할 때는 팀의 규칙에 따라 커밋 메시지를 작성한다. 규칙이 없다면 크리스 빔(Chris Beam)이 조언한 '깃 커밋 메시지를 작성하는 7가지 요령'(https://chris.beams.io/posts/git-commit)을 따르는 것도 좋다.

- 제목과 본문 사이에 빈 줄을 한 행 삽입한다
- 제목은 50자 이내로 제한한다
- 제목은 대문자로 쓴다
- 제목 끝에 마침표를 붙이지 않는다
- 제목은 명령형 문장으로 작성한다
- 본문의 각 행은 72자를 넘지 않게 한다
- 본문에는 코드가 '어떻게' 바뀌었는지보다는 '무슨' 코드가 '왜' 바뀌었는지를 설명한다

## 소프트웨어 개발에서 빠지기 쉬운 함정을 최대한 피하려면

코드를 처음부터 다시 작성하려 한다거나 표준을 무시하는 행동은 위험하다.

코드를 새로 작성하거나 표준 외의 방법을 도입하고자 한다면 여러분이 개선한 코드는 기존 코드보다 몇 배는 더 좋아야 한다. 비용이 너무 높으므로 그만큼 장점도 커야 한다.

### 되도록 검증된 기술을 사용하자

소프트웨어는 빠르게 변하는 분야다. 계속해서 새로운 도구나 언어, 프레임워크 등이 등장한다. 그렇기 때문에 온라인에서 찾을 수 있는 코드와 비교해보면 기존 코드는 마치 오래된 것처럼 보인다.

하지만 성공적인 기업이 오래된 라이브러리와 오래된 패턴으로 견고한 코드를 유지할 수 있는 데는 이유가 있다. 성공을 거두는 데는 시간이 걸리며, 기술을 갈아타는 것은 집중을 방해하는 요소가 되기 때문이다.

### 제발 악동은 되지 말자

단지 마음에 들지 않는다는 이유로 회사의 (또는 업계의) 표준을 무시해서는 안 된다.

어쩌면 여러분이 수행하려는 방식이 정말로 더 나은 방법일 수도 있다. 그렇다고 해서 악동처럼 구는 것은 좋은 생각이 아니다. 단기적으로는 다른 사람이 하는 대로 따르자. 그 방법이 표준으로 채택된 이유를 되도록 이해해야 한다. 어쩌면 여러분이 이해하지 못하고 있는 문제를 해결하기 위한 방안일 수도 있기 때문이다.

### 업스트림 커밋 없이 포크만 하는 것은 금물이다

**포크(fork)**란 다른 소스 코드 리포지토리에 대한 완전하며 독립적인 복사본으로서 자체적인 트렁크(trunk), 브랜치, 태그 등을 갖는다. 깃허브(GitHub) 같은 코드 공유 플랫폼에서는 업스트림(upstream) 리포지토리에 PR을 보내기 전에 해당 리포지토리를 포크한다.

회사 내부에서 포크한 리포지토리를 관리하는 것은 위험천만한 일이다. 개발자들은 '추후에' 업스트림 리포지토리에 코드를 기여할 거라고 서로 말한다. 하지만 그런 일은 거의 일어나지 않는다. 소소한 변경은 시간이 지나도 업스트림 리포지토리에 적용되지 않는다. 그러다 보면 결국 완전히 다른 소프트웨어를 운영하게 되고, 결국 업스트림 리포지토리에 기능을 추가하거나 버그를 수정하는 것이 엄청나게 어려워진다. 마침내 팀은 자신들이 전체 프로젝트를 유지보수하는 데 암묵적으로 동의했다는 사실을 깨닫게 된다. 어떤 회사는 내부의 변경사항을 적용하지 않으려고 자체 오픈 소스 프로젝트를 포크하기도 한다!

### 코드 재작성에 대한 욕구를 견디자

리팩터링을 하다 보면 기존 코드를 완전히 버리고 새로 작성하게 되는 경우가 있다. 기존 코드 리팩터링이 벅찬 나머지 기존 시스템을 통째로 날려버리고 모두 새로 작성하면 어떨까라는 생각까지 하게 된다. 코드를 새로 작성하는 것은 최후의 수단이라고 생각해야 한다. 수년에 걸친 우리의 경험에 비춰볼 때 의도대로 새 코드를 작성하기란 여간해선 쉽지 않다.

## 개발자의 필수 체크리스트

**○ 이것만은 지키자**

- 점진적으로 리팩터링하자
- 리팩터링 커밋과 기능 관련 커밋은 분리하자
- 변경사항을 작게 유지하자
- 처음 상태보다 코드를 더 깔끔하게 유지하자
- 평범한 기술을 사용하자

**✗ 이것만은 피하자**

- '기술 부채'라는 단어를 남용하지 말자
- 테스트를 목적으로 메소드나 변수를 외부에 공개해서는 안 된다
- 특정 언어에 연연하지 말자
- 회사의 표준과 도구를 무시해서는 안 된다
- 업스트림 커밋 없이 코드베이스를 포크해서는 안 된다

## 레벨업을 위한 읽을거리

- 『레거시 코드 활용 전략』
- The Legacy Code Programmer's Toolbox (레거시 코드 프로그래머의 툴박스)
- 마틴 파울러의 블로그 https://martinfowler.com/
- 『리팩터링 2판』 (한빛미디어, 2020년, 개앞맵시 외 옮김)
